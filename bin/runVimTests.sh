#!/bin/bash
##########################################################################/^--#
##
# FILE: 	runVimTests.sh
# PRODUCT:	runVimTests
# AUTHOR: 	Ingo Karkat <ingo@karkat.de>
# DATE CREATED:	02-Feb-2009
#
###############################################################################
# CONTENTS: 
#   This script implements a testing framework for VIM. 
#   
# REMARKS: 
#   
# DEPENDENCIES:
#   - runVimMsgFilter.vim, located in this script's directory. 
#
# Copyright: (C) 2009 by Ingo Karkat
#   The VIM LICENSE applies to this script; see 'vim -c ":help copyright"'.  
#
# FILE_SCCS = "@(#)runVimTests.sh	1.00.007	(02-Mar-2009)	runVimTests";
#
# REVISION	DATE		REMARKS 
#   1.00.007	02-Mar-2009	Reviewed for publication. 
#	006	28-Feb-2009	BF: FAIL (msgout) and FAIL (tap) didn't print
#				test header in non-verbose mode. 
#				Refactored :printTestHeader so that it does the
#				check for already printed header itself. 
#	005	25-Feb-2009	Now only printing failed tests and errors, and
#				only explicitly mentioning the test if it wasn't
#				successful. This greatly reduces the visual
#				output the user has to scan.
#				Added --verbose option to also print successful
#				tests, the previous default behavior. 
#				Added empty line between individual tests. 
#	004	24-Feb-2009	Added short options -0/1/2 for the plugin load
#				level. 
#	003	19-Feb-2009	Added explicit option '--user' for the default
#				VIM mode, and adding 'user' to
#				%vimVariableOptionsValue% (so that tests can
#				easily check for that mode). Command-line
#				argument parsing now ensures that only one mode
#				is specified. 
#	002	11-Feb-2009	Completed porting of Windows shell script. 
#	001	02-Feb-2009	file creation
###############################################################################

# Enable extended file pattern matching operators from ksh
# (?(pattern-list), !(pattern-list), ...) in bash. 
shopt -qs extglob

initialize()
{
    readonly scriptDir=$(readonly scriptFile="$(type -P -- "$0")" && dirname -- "$scriptFile" || exit 1)
    [ -d "$scriptDir" ] || { echo >&2 "ERROR: cannot determine script directory!"; exit 1; } 

    # Prerequisite VIM script to match the message assumptions against the actual
    # message output. 
    readonly runVimMsgFilterScript=${scriptDir}/runVimMsgFilter.vim
    if [ ! -r "$runVimMsgFilterScript" ]; then
	echo >&2 "ERROR: Script prerequisite \"${runVimMsgFilterScript}\" does not exist!"
	exit 1
    fi

    # VIM variables set by the test framework. 
    readonly vimVariableOptionsName=g:runVimTests
    vimVariableOptionsValue=
    readonly vimVariableTestName=g:runVimTest

    # VIM mode of sourcing scripts. 
    vimMode=

    # Default VIM executable. 
    vimExecutable='vim'

    # Default VIM command-line arguments. 
    #
    # Always wait for the edit session to finish (only applies to the GUI
    # version, is ignored for the terminal version), so that this script can
    # process the files generated by the test run. 
    vimArguments=-f

    # Use silent-batch mode (-es) when the test log is not printed to stdout (but
    # redirected into a file or pipe). This avoids that the output is littered with
    # escape sequences and suppresses the VIM warning and a small delay:
    # "Vim: Warning: Output is not to a terminal".
    # (Just passing '-T dumb' is not enough.)
    [ -t 1 ] || vimArguments="$vimArguments -es"

    # Optional user-provided setup scripts. 
    readonly vimLocalSetupScript=_setup.vim
    readonly vimGlobalSetupScript=${scriptDir}/$(basename -- "$0")Setup.vim
    [ -r "$vimGlobalSetupScript" ] && vimArguments="$vimArguments $(vimSourceCommand "$vimGlobalSetupScript")"

    verboseLevel=0
    isExecutionOutput='true'
}
verifyVimModeSetOnlyOnce()
{
    if [ "$vimMode" ]; then
	{ echo "ERROR: \"${1}\": Mode already set!"; echo; printShortUsage; } >&2; exit 1
    fi
}

printShortUsage()
{
    cat <<SHORTHELPTEXT
Usage: "$(basename "$0")" [-0|--pure|-1|--default|-2|--user] [--source filespec [--source filespec [...]]] [--runtime plugin/file.vim [--runtime autoload/file.vim [...]]] [--vimexecutable path/to/vim] [-g|--graphical] [--summaryonly|-v|--verbose] [-d|--debug] [-?|-h|--help] test001.vim|testsuite.txt|path/to/testdir/ [...]
SHORTHELPTEXT
}
printUsage()
{
    # This is the short help when launched with no or incorrect arguments. 
    # It is printed to stderr to avoid accidental processing. 
    printShortUsage >&2
    cat >&2 <<MOREHELP
Try "$(basename "$0")" --help for more information.
MOREHELP
}
printLongUsage()
{
    # This is the long "man page" when launched with the help argument. 
    # It is printed to stdout to allow paging with 'more'. 
    cat <<HELPDESCRIPTION
A testing framework for VIM. 
HELPDESCRIPTION
    echo
    printShortUsage
    cat <<HELPTEXT
    -0|--pure		Start VIM without loading .vimrc and plugins, but in
			nocompatible mode. Adds 'pure' to ${vimVariableOptionsName}.
    -1|--default	Start VIM only with default settings and plugins,
			without loading user .vimrc and plugins.
			Adds 'default' to ${vimVariableOptionsName}.
    -2|--user		(Default:) Start VIM with user .vimrc and plugins.
    --source filespec	Source filespec before test execution.
    --runtime filespec	Source filespec relative to ~/.vim. Can be used to
			load the script-under-test when using --pure.
    --vimexecutable	Use passed VIM executable instead of the one
	path/to/vim	found in \$PATH.
    -g|--graphical	Use GUI version of VIM.
    --summaryonly	Do not show detailed transcript and differences, during
			test run, only summary. 
    -v^|--verbose	Show passed tests and more details during test execution.
    -d|--debug		Test debugging mode: Adds 'debug' to ${vimVariableOptionsName}
			variable inside VIM (so that tests do not exit or can
			produce additional debug info).
HELPTEXT
}

executionOutput()
{
    [ "$isExecutionOutput" ] && echo "$@"
}
echoOk()
{
    [ "$isExecutionOutput" -a $verboseLevel -gt 0 ] && echo "OK ($1)"
}
echoStatus()
{
    printTestHeader "$testFile" "$testName"
    if [ "$isExecutionOutput" ]; then
	if [ "$3" ]; then
	    echo "$1 ($2): $3"
	else
	    echo "$1: $2"
	fi
    fi
}
echoError()
{
    echoStatus 'ERROR' "$@"
}
echoFail()
{
    echoStatus 'FAIL' "$@"
}
makePlural()
{
    if [ $1 -eq 1 ]; then
	echo "$2"
    else
	echo "${2}s"
    fi
}
vimSourceCommand()
{
    # Note: With -S {file}, VIM wants {file} escaped for Ex commands. (It should
    # really escape {file} itself, as it does for normal {file} arguments.)
    # As we don't know the VIM version, we cannot work around this via
    #	-c "execute 'source' fnameescape('${testfile}')"
    # Thus, we just escape spaces and hope that no other special string (like %,
    # # or <cword>) is part of a test filename. 
    echo "-S '${1// /\\ }'"
}

processTestEntry()
{
    if [ -d "$1" ]; then
	runDir "$1"
    elif [ "${1##*.}" = "vim" ]; then
	runTest "$1"
    elif [ -r "$1" ]; then
	runSuite "$1"
    else
	let cntError+=1
	echo >&2 "ERROR: Suite file \"${1}\" doesn't exist. "
    fi
}

runSuite()
{
    typeset -r suiteDir=$(dirname -- "$1")
    typeset -r suiteFilename=$(basename -- "$1")

    # Change to suite directory so that relative paths and filenames are
    # resolved correctly. 
    pushd "$suiteDir" >/dev/null

    local testEntry
    local IFS=$'\n'
    for testEntry in $(cat -- "$suiteFilename")
    do
	case "$testEntry" in
	    \#*|'') continue;;
	esac
	processTestEntry "$testEntry"
    done

    popd >/dev/null
}
runDir()
{
    local testFilename
    for testFilename in "${1}/"*.vim
    do
	runTest "$testFilename"
    done
}

addToListFailed()
{
    echo "$listFailed" | grep -- "$1" >/dev/null || listFailed="${listFailed}${1}, "
}
addToListError()
{
    echo "$listError" | grep -- "$1" >/dev/null || listError="${listError}${1}, "
}
printTestHeader()
{
    [ "$isPrintedHeader" ] && return
    isPrintedHeader='true'
    [ ! "$isExecutionOutput" ] && return

    local -r headerMessage="${2}:"
    echo
    # If the first line of the test script starts with '" Test', include this as
    # the test's synopsis in the test header. Otherwise, just print the test
    # name. Limit the test header to one unwrapped output line, i.e. truncate to
    # 80 characters. 
    sed -n -e "1s/^\\d034 \\(Test.*\\)$/${headerMessage} \\1/p" -e 'tx' -e "1c${headerMessage}" -e ':x' -- "$1" | sed '/^.\{80,\}/s/\(^.\{,76\}\).*$/\1.../'
}

compareOutput()
{
    diff -q -- "$1" "$2" >/dev/null
    if [ $? -eq 0 ]; then
	let thisOk+=1
	echoOk 'out'
    elif [ $? -eq 1 ]; then
	let thisFail+=1
	if [ "$isExecutionOutput" ]; then
	    printTestHeader "$testFile" "$testName"
	    printf "%-$((${COLUMNS:-80}/2-2))s|   %s\n" "FAIL (out): expected output" "actual output"
	    diff --side-by-side --width ${COLUMNS:-80} -- "$1" "$2"
	fi
    else
	let thisError+=1
	echoError 'out' 'diff operation failed.'
    fi
}
compareMessages()
{
    typeset -r testMsgresult="${3}.msgresult"
    [ -f "$testMsgresult" ] && rm "$testMsgresult"

    # Use silent-batch mode (-es) to match the message assumptions against the
    # actual message output. 
    eval "vim -N -u NONE -es -c 'set nomore' $(vimSourceCommand "$runVimMsgFilterScript") -c 'RunVimMsgFilter' -c 'quitall!' -- \"$testMsgok\""

    if [ ! -r "$testMsgresult" ]; then
	let thisError+=1
	echoError 'msgout' 'Evaluation of test messages failed.'
	return
    fi
    typeset -r evaluationResult=$(sed -n '1s/^\([A-Z][A-Z]*\).*/\1/p' -- "$testMsgresult")
    local isPrintEvaluation='true'
    case "$evaluationResult" in
	OK)	let thisOk+=1
		if [ $verboseLevel -eq 0 ]; then
		    isPrintEvaluation=
		fi
		;;
	FAIL)	let thisFail+=1;;
	ERROR)	let thisError+=1;;
	*)	echo >&2 "ASSERT: Received unknown result \"${evaluationResult}\" from RunVimMsgFilter."; exit 1;;
    esac
    if [ "$isExecutionOutput" -a "$isPrintEvaluation" ]; then
	printTestHeader "$testFile" "$testName"
	cat -- "$testMsgresult"
    fi
}
parseTapOutput()
{
    local tapTestNum=
    local tapTestCnt=0
    local tapTestIsFailures=

    local tapLine
    local IFS=$'\n'
    while read tapLine
    do
	case "$tapLine" in
	    \#*|'')		continue;;
	    ok*)		let thisOk+=1   thisRun+=1 tapTestCnt+=1;;
	    not\ ok*)		let thisFail+=1 thisRun+=1 tapTestCnt+=1; tapTestIsFailures='true';;
	    +([0-9])..+([0-9]))	local startNum=${tapLine%%.*}
				local endNum=${tapLine##*.}
				let tapTestNum=endNum-startNum+1
				;;
	esac
    done < "$1"

    # Print the entire TAP output if in verbose mode, else only print the failed
    # TAP test plus any failure details in the lines following it. 
    if [ "$isExecutionOutput" ]; then
	if [ $verboseLevel -gt 0 ]; then
	    # In verbose mode, the test header has already been printed. 
	    cat -- "$1"
	else
	    [ "$tapTestIsFailures" ] && printTestHeader "$testFile" "$testName"
	    cat -- "$1" | sed -n -e '${/^#/H;x;/^not ok/p}' -e '/^not ok/{x;/^not ok/p;b}' -e '/^#/{H;b}' -e 'x;/^not ok/p'
	fi
    fi

    if [ ! "$tapTestNum" ]; then
	let thisTests+=tapTestCnt
	return
    fi

    local tapTestDifference
    let tapTestDifference=tapTestNum-tapTestCnt
    [ $tapTestDifference -lt 0 ] && let tapTestDifference*=-1
    if [ $tapTestCnt -lt $tapTestNum ]; then
	let thisTests+=tapTestNum
	echoError 'tap' "Not all $tapTestNum planned tests have been executed, $tapTestDifference $(makePlural $tapTestDifference 'test') missed."
	let thisError+=1
    elif [ $tapTestCnt -gt $tapTestNum ]; then
	let thisTests+=tapTestCnt
	echoError 'tap' "$tapTestDifference more test $(makePlural $tapTestDifference 'execution') than planned."
	let thisError+=1
    else
	let thisTests+=tapTestNum
    fi
}

runTest()
{
    if [ ! -f "$1" ]; then
	let cntError+=1
	echo >&2 "ERROR: Test file \"$1\" doesn't exist."
	return
    fi

    typeset -r testDirspec=$(dirname -- "$1")
    typeset -r testFile=$(basename -- "$1")
    typeset -r testFilespec=$(cd "$testDirspec" && echo "${PWD}/${testFile}") || { echo >&2 "ERROR: Cannot determine absolute filespec!"; exit 1; }
    typeset -r testName=${testFile%.*}

    # The setup script is not a test, silently skip it. 
    [ "$testFile" == "$vimLocalSetupScript" ] && return

    typeset -r testOk=${testName}.ok
    typeset -r testOut=${testName}.out
    typeset -r testMsgok=${testName}.msgok
    typeset -r testMsgout=${testName}.msgout
    typeset -r testTap=${testName}.tap

    pushd "$testDirspec" >/dev/null

    # Remove old output files from the previous test run. 
    local file
    for file in "$testOut" "$testMsgout" "$testTap"
    do
	[ -f "$file" ] && rm "$file"
    done

    # Source local setup script before the testfile. 
    local vimLocalSetup
    [ -f "$vimLocalSetupScript" ] && vimLocalSetup=" $(vimSourceCommand "${vimLocalSetupScript}")"

    local isPrintedHeader=
    [ $verboseLevel -gt 0 ] && printTestHeader "$testFile" "$testName"

    # Default VIM arguments and options:
    # -n		No swapfile. 
    # :set nomore	Suppress the more-prompt when the screen is filled with messages
    #			or output to avoid blocking. 
    # :set verbosefile	Capture all messages in a file. 
    # :let $vimVariableTestName = Absolute test filespec. 
    # :let $vimVariableOptionsName = Options for this test run, concatenated with ','. 
    eval "$vimExecutable -n -c \"let ${vimVariableTestName}='${testFilespec//\'/\'\'}'|set nomore verbosefile=${testMsgout// /\\ }\" ${vimArguments}${vimLocalSetup} $(vimSourceCommand "$testFile")"

    local thisTests=0
    local thisRun=0
    local thisOk=0
    local thisFail=0
    local thisError=0

    # Method output. 
    if [ -r "$testOk" ]; then
	let thisTests+=1
	if [ -r "$testOut" ]; then
	    let thisRun+=1
	    compareOutput "$testOk" "$testOut" "$testName"
	else
	    let thisError+=1
	    echoError 'out' 'No test output.'
	fi
    fi

    # Method message output. 
    if [ -r "$testMsgok" ]; then
	let thisTests+=1
	if [ -r "$testMsgout" ]; then
	    let thisRun+=1
	    compareMessages "$testMsgok" "$testMsgout" "$testName"
	else
	    let thisError+=1
	    echoError 'msgout' 'No test messages.'
	fi
    fi

    # Method TAP. 
    if [ -r "$testTap" ]; then
	parseTapOutput "$testTap" "$testName"
    fi

    # Results evaluation. 
    if [ $thisTests -eq 0 ]; then
	let thisError+=1
	echoError 'No test results at all.'
    else
	let cntTests+=thisTests
    fi
    if [ $thisRun -ge 1 ]; then
	let cntRun+=thisRun
    fi
    if [ $thisOk -ge 1 ]; then
	let cntOk+=thisOk
    fi
    if [ $thisFail -ge 1 ]; then
	let cntFail+=thisFail
	addToListFailed "$testName"
    fi
    if [ $thisError -ge 1 ]; then
	let cntError+=thisError
	addToListError "$testName"
    fi

    popd >/dev/null
}

execute()
{
    cntTests=0
    cntRun=0
    cntOk=0
    cntFail=0
    cntError=0
    listFailed=
    listError=

    executionOutput
    if [ "$vimArguments" ]; then
	executionOutput 'Starting test run with these VIM options:'
	executionOutput "$vimExecutable $vimArguments"
    else
	executionOutput 'Starting test run.'
    fi

    for arg
    do
	processTestEntry "$arg"
    done
}
report()
{
    echo
    echo "$cntTests $(makePlural $cntTests 'test'), $cntRun run: $cntOk OK, $cntFail $(makePlural $cntFail 'failure'), $cntError $(makePlural $cntError 'error')."
    [ "$listFailed" ] && echo "Failed tests: ${listFailed%, }"
    [ "$listError" ] && echo "Tests with errors: ${listError%, }"

    let cntAllProblems=cntError+cntFail
    if [ $cntAllProblems -ne 0 ]; then
	exit 1
    fi
}

#- main -----------------------------------------------------------------------
initialize

if [ $# -eq 0 ]; then
    printUsage
    exit 1
fi
while [ $# -ne 0 ]
do
    case "$1" in
	--help|-h|-\?)	    shift; printLongUsage; exit 1;;
	--pure|-0)	    verifyVimModeSetOnlyOnce "$1"
			    shift
			    vimArguments="-N -u NONE $vimArguments"
			    vimMode='pure'
			    ;;
	--default|-1)	    verifyVimModeSetOnlyOnce "$1"
			    shift
			    vimArguments="--cmd 'set rtp=\$VIM/vimfiles,\$VIMRUNTIME,\$VIM/vimfiles/after' -N -u NORC -c 'set rtp&' $vimArguments"
			    vimMode='default'
			    ;;
	--user|-2)	    verifyVimModeSetOnlyOnce "$1"
			    shift
			    vimMode='user'
			    ;;
	--runtime)	    shift; vimArguments="$vimArguments $(vimSourceCommand "$HOME/.vim/$1")"; shift;;
	--source)	    shift; vimArguments="$vimArguments $(vimSourceCommand "$1")"; shift;;
	--vimexecutable)    shift
			    vimExecutable=$1
			    shift
			    if ! type -P -- "$vimExecutable" >/dev/null; then
				echo >&2 "ERROR: \"${vimExecutable}\" is not a VIM executable!"
				exit 1
			    fi
			    ;;
	--graphical|-g)	    shift
			    gvimExecutable=$(echo "$vimExecutable" | sed -e 's+^vim$+gvim+' -e 's+/vim$+/gvim+')
			    if [ "$gvimExecutable" != "$vimExecutable" ] && type -P -- "$gvimExecutable" >/dev/null; then
				vimExecutable=$gvimExecutable
			    else
				vimArguments="-g $vimArguments"
			    fi
			    ;;
	--summaryonly)	    shift; isExecutionOutput='true';;
	--verbose|-v)	    shift; let verboseLevel+=1;;
	-d|--debug)	    shift; vimVariableOptionsValue="${vimVariableOptionsValue}debug,";;
	--)		    shift; break;;
	-*)		    { echo "ERROR: Unknown option \"${1}\"!"; echo; printShortUsage; } >&2; exit 1;;
	*)		    break;;
    esac
done
[ $# -eq 0 ] && { printUsage; exit 1; }
[ "$vimMode" ] || vimMode='user'
vimVariableOptionsValue="${vimMode},${vimVariableOptionsValue}"
vimVariableOptionsValue="${vimVariableOptionsValue%,}"
vimArguments="$vimArguments --cmd \"let ${vimVariableOptionsName}='${vimVariableOptionsValue}'\""

execute "$@"
report

